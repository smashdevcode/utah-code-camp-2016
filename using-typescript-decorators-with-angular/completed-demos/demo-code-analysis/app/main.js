
(function() {

    // global decorate utility method (generated by TypeScript)

    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        console.group('__decorate Utility Method');

        // when decorating a method, this method is called like this:
        // __decorate([ log ], MyClass.prototype, "myMethod", null);

        // so...
        // decorators = [ log ]
        // target = MyClass.prototype
        // key = "myMethod"
        // desc = null

        console.group('Parameters');
        console.log('decorators: %s', decorators);
        console.log('target: %s', target);
        console.log('key: %s', key);
        console.log('desc: %s', desc);
        console.groupEnd();

        var

            // c = the number of arguments passed to this method
            c = arguments.length,

            // r = if less then 3 arguments, then use the "target",
            // else assign "desc" to the result of Object.getOwnPropertyDescriptor if its null
            // and then return "desc"
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,

            // d = undefined
            d;

        console.group('Variables');
        console.log('c: %s', c);
        console.log('r: (next line)');
        console.log(r);
        console.log('d: %s', d);
        console.groupEnd();

        console.group('Decorating');

        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {

            // if the reflect-metadata polyfill is loaded
            // then we'll use that to decorate the target

            console.log('Calling polyfilled Reflect.decorate method...');
            r = Reflect.decorate(decorators, target, key, desc);

        } else {

            // else we'll loop over the provided decorators in reverse order
            // calling each in turn with the correct number of parameters

            console.log('Looping over the provided decorators...')

            for (var i = decorators.length - 1; i >= 0; i--) {

                console.log('Decorator #%s', i);

                if (d = decorators[i]) {
                    console.log(d);

                    // call the decorator with the correct parameters
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                } else {
                    console.log('Decorator not defined!');
                }

            }

        }

        console.groupEnd();

        console.groupEnd();

        // if we have more than 3 arguments and a result from the decorator method call
        // then define a new property on the target
        // otherwise just return the result of the decorator method call
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    // global metadata utility method (generated by TypeScript)

    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") {
            console.group('__metadata Utility Method');
            console.log(k);
            console.log(v);
            console.groupEnd();

            return Reflect.metadata(k, v);
        }
    };

    // helper method for displaying metadata (this one is all mine)

    var __showMetadata = (this && this.__showMetadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.getMetadata === "function") {
            console.group('Reflection Metadata');
            console.log('Type: %s', Reflect.getMetadata('design:type', v, k));
            console.log('Param Types: %s', Reflect.getMetadata('design:paramtypes', v, k));
            console.log('Return Type: %s', Reflect.getMetadata('design:returntype', v, k));
            console.groupEnd();
        }
    };

    // the decorator function
    function log(target, propertyKey, descriptor) {
        console.group('Decorator Function');
        console.log(target);
        console.log(propertyKey);
        console.log(descriptor);
        console.groupEnd();

        // capture the original method
        var originalMethod = descriptor.value;

        // redefine the method
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }

            console.log('The method args are: ' + JSON.stringify(args));

            // call the original method
            var result = originalMethod.apply(this, args);

            console.log('The return value is: ' + result);

            return result;
        };

        return descriptor;
    }

    // the class function
    var MyClass = (function () {

        // define the constructor function
        function MyClass() {
        }

        // add the myMethod to the prototype
        MyClass.prototype.myMethod = function (arg1, arg2) {
            console.log('Executing myMethod');
            return "Message -- arg1: " + arg1 + ", arg2: " + arg2;
        };

        // call the decorate method
        __decorate([
            log,
            // metadata is only emitted if you have the "emitDecoratorMetadata"
            // compiler option set to "true"
            __metadata('design:type', Function),
            __metadata('design:paramtypes', [String, Number]),
            __metadata('design:returntype', void 0)
        ], MyClass.prototype, "myMethod", null);

        return MyClass;
    }());

    var myClass = new MyClass();
    myClass.myMethod('testing', 1);

    __showMetadata('myMethod', myClass);

})();
